<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <section>
    <header>http协议类</header>
    <ol>
      <li>http协议的主要特点
        <ol>
          <li>简单快速: 每个资源uri是固定的</li>
          <li>灵活: 通过一个http协议可以传输不同的数据类型(header部分)</li>
          <li>无连接: 连接一次就断掉</li>
          <li>无状态: 客户端和服务端是两种身份, 服务端是无法两次连接的身份是否一样, 不会记录状态</li>
        </ol>
      </li>
      <li>http报文组成部分
        <ol>
          <li>请求报文: 
            <ol>
              <li>请求行: method, http地址, http协议, http版本</li>
              <li>请求头: key - value值, 告诉服务端我需要什么</li>
              <li>空行: 告诉服务端往下是请求体</li>
              <li>请求体: 数据不符</li>
            </ol>
          </li>
          <li>响应报文: 
              <ol>
                <li>状态行</li>
                <li>响应头</li>
                <li>空行</li>
                <li>响应体</li>
              </ol>
            </li>
        </ol>
      </li>
      <li>http方法
        <ol>
          <li>GET - 获取资源</li>
          <li>POST - 传输资源</li>
          <li>PUT - 更新资源</li>
          <li>DELETE - 删除资源</li>
          <li>HEAD - 获得报文首部</li>
        </ol>
      </li>
      <li>post和get区别
        <ol>
          <li>GET在浏览器回退是是无害的, POST会再次提交请求</li>
          <li>GET产生的URL地址可以被收藏, 而POST不可以</li>
          <li>GET请求会被浏览器主动缓存, POST不会, 除非手动设置</li>
          <li>GET请求只能进行url编码, 而POST支持多种编码</li>
          <li>GET请求的参数会被完整的保留在浏览器的历史记录里, POST中的参数不会被保留</li>
          <li>GET请求在url中的参数是有长度限制的, POST没有</li>
          <li>对于参数的数据类型, GET只接受ASCII字符, POST没有限制</li>
          <li>GET比POST更不安全, 参数直接暴露在url上, 不能用来传递敏感信息</li>
          <li>GET参数通过url传递, POST放在Request body中</li>
        </ol>
      </li>
      <li>http状态码
        <ol>
          <li>1xx: 指示信息 - 表示请求已经接收, 继续处理</li>
          <li>2xx: 成功 - 表示请求已经被成功接收</li>
          <li>3xx: 重定向 - 要完成请求必须进行更进一步的操作</li>
          <li>4xx: 客户端错误 - 请求有语法错误或请求无法实现</li>
          <li>5xx: 服务器错误 - 服务器未能实现合法请求</li>
          <li>举例:
            <ol>
              <li>200 OK: 客户端请求成功</li>
              <li>206 Partial Content: 客户端发送了一个带有Range头的GET请求, 服务器完成了它(视频音频文件很大时候)</li>
              <li>301 Move Permanently: 所请求的页面已经转移至新的url</li>
              <li>302 Found: 所有页面已经临时转至新的url</li>
              <li>304 Not Modfied: 客户端有缓存的文档想服务器发送了一个条件性的请求, 服务器告诉客户端原来缓存的文件可以继续用</li>
              <li>400 Bad Request: 客户端语法错误, 不被服务器理解</li>
              <li>401: 没有权限</li>
              <li>403: 资源禁止访问</li>
              <li>404: 资源不存在</li>
              <li>500: 服务器错误</li>
              <li>503: 请求未完成, 服务器过载</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>什么是持久连接
        <li>http协议支持持久连接(1.1版本)</li>
        <li>使用keep-Alive模式使客户端和服务端的连接持久有效, 有后续请求时避免了重新建立连接</li>
      </li>
      <li>什么是管线化
        <ol>
          <li>正常情况下持久链接消息传递的过程类似于: 请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3</li>
          <li>管线化类似于打包一部分请求再发送, 服务器在把响应打包回来: 请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3</li>
          <li>特点: 
            <ol>
              <li>管线化机制通过持久连接完成, 仅HTTP/1.1支持此技术</li>
              <li>只有GET和HEAD请求可以管线化, 而POST有所限制</li>
              <li>初次建立连接时不应启动管线机制, 因为对方不一定支持HTTP/1.1版本协议</li>
              <li>管线化不会影响响应到达的顺序, 顺序并未改变</li>
              <li>HTTP/1.1要求服务器端也支持管线化, 但不需要做管线化处理, 只要求对管线化请求不失败</li>
              <li>由于服务器和代理程序对管线化支持并不好, 火狐和谷歌浏览器并未默认开启管线化支持</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </section>
</body>
</html>