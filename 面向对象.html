<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <section>
    <header>面向对象</header>
    <article>
      <ol>
        <li>类与实例
          <ol>
            <li>类的声明</li>
            <li>生成实例</li>
          </ol>
        </li>
        <li>类与继承
          <ol>
            <li>如何实现继承</li>
            <li>继承的几种方式</li>
          </ol>
        </li>
      </ol>
    </article>
  </section>
</body>
<script>
  // 类的声明
  function Animal() {
    this.name = 'name'
  }
  /*
  *ES6类的声明
  */
  class Animal2 {
    constructor () {
      this.name = 'name'
    }
  }
  // 实例化
  console.log(new Animal(), new Animal2())

  /*
  * 类的继承(重点) - 原型链: 没有原型链无法实现继承
  */
  // 1 借助构造函数实现继承
  // 原理: 利用call在子类内部改变父类的this指向, 将父类的属性和方法挂载到子类上 
  // 缺点: 无法继承父类原型链上的属性和方法
  function Parent1() {
    this.name = 'parent1'
  }
  Parent1.prototype.say = function() {
    console.log('叫爸爸')
  }
  function Child1() {
    Parent1.call(this) // 通过call(apply, bind)改变函数的上下文, 改变this指向, 导致父类执行的属性挂载到子类上
    this.type = 'child1'
  }

  var chi = new Child1()
  console.log(chi)

  // 2 借助原型链
  function Parent2(){
    this.name = 'parent2'
  }
  Parent2.prototype.age = 11
  function Child2() {
    this.type = 'child2'
  }
  // 重点⬇️: 
  Child2.prototype = new Parent2()
  console.log(new Child2)
</script>
</html>